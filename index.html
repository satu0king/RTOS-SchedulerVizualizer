<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>RTOS Schedulers</title>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="styles.css">
    <script src="./canvas.js"></script>
    <script src="./core.js"></script>
    <script src="./schedulers.js"></script>
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
</head>

<body onload="canvas.setup()">




    <canvas id="canvasArea" style="background-color:lightgrey;width:100%;height:500px"></canvas>
    <div style="padding:10px">
        <button onclick="newJob()"> Add Job</button>
        <button onclick="updateJobList()"> Generate Schedule</button>
        Context Switch OverHead: <input type="number" name="contextOverHead" value="0" min="0" max="10"
            onchange="updateJobList();"> </input>
        Number Of CPUs: <input type="number" name="threadCount" value="1" min="1" max="10"
            onchange="updateJobList();"> </input>

        Scheduling Algorithm:
        <select id="algo" onchange="updateJobList();">
            <option value="RMS">RMS</option>
            <option value="PRIORITY">Priority</option>
            <option value="EDF">EDF</option>
        </select>
    </div>


    <div style="overflow: hidden;">
        <div style="width:700px; float:left;">
            <ul id="sortable" class="taskList" style="width:630px;">

            </ul>

            Note:
            <ul>
                <li>Deadline is amount of time from release time</li>
                <li>If deadline is zero, time period is taken as deadline</li>
                <li>Try the different algorithms</li>
                <li>Try tweaking the number of CPUs  </li>
                <li>Try tweaking the Context Switch Overhead</li>
                <li>For priority based scheduling, the priority is decided by the list order</li>
            </ul>
        </div>

        <div id="display" style="overflow: hidden;">

        </div>
    </div>




    <!-- position: fixed; right:10px; top:500px -->



    <script>


        var jobCount = 0;
        function newJob() {
            jobCount++;
            let newTask =
                `<li class="ui-state-default" id = "job${jobCount}">
              <div class = "task">
                <span class="ui-icon ui-icon-arrowthick-2-n-s"></span>
                  Name: <input type="text" name ="name" id = 'name' value = "Job ${jobCount}" onchange="updateJobList();"> </input>
                  Period: <input type="number" name = "period" value = "50"  min = "1" onchange="updateJobList();"> </input>
                  Job Time: <input type="number" name = "time" value = "10"  min = "1" onchange="updateJobList();"> </input>
                  Deadline: <input type="number" name = "deadline" min = "0" value = "0" onchange="updateJobList();"> </input>
                  <button onClick="$('#job${jobCount}').remove();updateJobList();"> X</button>
              </div>
            </li>`
            $('.taskList').append(newTask);

            updateJobList();

        }

        function updateJobList() {
            let jobList = []
            $(".task").each(function (idx, li) {

                jobList.push({
                    name: $(li).children('input[name="name"]').val(),
                    time: parseInt($(li).children('input[name="time"]').val()),
                    period: parseInt($(li).children('input[name="period"]').val()),
                    deadline: parseInt($(li).children('input[name="deadline"]').val())
                })
                // and the rest of your code
            });

            let overhead = parseInt($('input[name="contextOverHead"]').val());
            let threadCount = parseInt($('input[name="threadCount"]').val());

            console.log(jobList);

            generateSchedule(jobList, overhead, threadCount);

        }

        function generateSchedule(jobList, overhead, threadCount) {
            let hyperPeriod = 1;

            let jobIdx = {}

            for (let i = 0; i < jobList.length; i++) {
                hyperPeriod = lcm(hyperPeriod, jobList[i].period);
                jobIdx[jobList[i].name] = i;
            }

            let metadata = {}
            metadata.hyperPeriod = hyperPeriod;
            metadata.jobIdx = jobIdx;
            metadata.jobList = jobList;

            let schedulerFn = SchedulerFunction[document.getElementById("algo").value];
            let scheduler = new Scheduler(overhead, threadCount, jobList, hyperPeriod, schedulerFn);
            let eventList = scheduler.process();

            let cpuTime = hyperPeriod * threadCount;
            let processTime = 0;
            let idleTime = 0;
            let overheadTime = 0;
            for (let i = 0; i < threadCount; i++) {
                processTime += scheduler.cpus[i].processTime;
                overheadTime += scheduler.cpus[i].overheadTime;
                idleTime += scheduler.cpus[i].idleTime;
            }

            metadata.cpuUtilization = Math.round(processTime * 10000.0 / cpuTime) / 100.0;
            metadata.cpuWastage = Math.round(overheadTime * 10000.0 / cpuTime) / 100.0;
            metadata.cpuIdle = Math.round(idleTime * 10000.0 / cpuTime) / 100.0;
            metadata.hyperPeriod = hyperPeriod;

            metadata.possible = scheduler.valid;
            render(eventList, metadata);
        }



        function render(eventList, metadata) {
            canvas.clear();
            $("#display").empty();
            
            if (!metadata.possible) {
                
                $("#display").append(`Invalid Task List. Try the following things: 
                <ul>
                    <li> Increase CPU Count</li>
                    <li> Decrease Context Switch Overhead</li>
                    <li> Deleting a Job</li>
                    <li> Changing the scheduling algorithm</li>
                    <li> Changing priority of the jobs</li>
                    <li> Changing deadline of the jobs</li>
                    <li> Reducing job time of the jobs</li>
                </ul>
                `);
                return;
            }

            
            $("#display").append("<h3>Legend</h3>")
            $("#display").append("Blue - CPU is being Used<br>")
            $("#display").append("Yellow - CPU is wasted<br>")
            $("#display").append("Gray - CPU is idle<br>")
            $("#display").append("Red - Job Release Time<br>")
            $("#display").append("<h3>Stats</h3>")

            $("#display").append(`CPU Utilization - ${metadata.cpuUtilization}%<br>`);
            $("#display").append(`CPU Idle - ${metadata.cpuIdle}%<br>`);
            $("#display").append(`CPU Wastage - ${metadata.cpuWastage}%<br>`);
            $("#display").append(`Hyper Period - ${metadata.hyperPeriod}`);


            let jobCount = Object.keys(eventList.jobs).length
            let yCount = jobCount + eventList.cpus.length;

            const margin = 20;
            const offsetX = 100 + margin;
            const offsetY = margin;
            const width = canvas.width - offsetX - margin;
            const height = canvas.height - offsetY - margin - 20;

            const taskMargin = 10;
            const taskHeight = Math.min(100, (height - (yCount - 1) * taskMargin) / yCount);
            const hyperPeriod = metadata.hyperPeriod;

            function x(time) { return width * time / hyperPeriod + offsetX; }
            function y(item) {
                if (typeof item == "string") return metadata.jobIdx[item] * (taskMargin + taskHeight) + offsetY;
                return [item + jobCount] * (taskMargin + taskHeight) + offsetY;
            }

            // Draw Axis
            canvas.setColor("Black");
            canvas.setLineThickness(1);
            canvas.setDrawMode("stroke")
            canvas.drawLine(offsetX, offsetY + height, offsetX + width, offsetY + height); // X Axis
            canvas.drawLine(offsetX, offsetY + height, offsetX, offsetY); // YAxis

            let xAxisTick = Math.ceil(hyperPeriod / 50.0);

            canvas.setColor("rgba(1, 1, 1, 0.2)");
            for (let t = 0; t <= hyperPeriod; t += xAxisTick)
                canvas.drawLine(x(t), offsetY, x(t), offsetY + height + 3);

            for (let i = 0; i < yCount; i++) {
                canvas.drawLine(offsetX, i * (taskHeight + taskMargin) - taskMargin * 0.5 + offsetY, offsetX + width, i * (taskHeight + taskMargin) - taskMargin * 0.5 + offsetY);
            }

            canvas.setColor("black");
            canvas.ctx.textAlign = "center";
            for (let t = 0; t <= hyperPeriod; t += xAxisTick)
                canvas.drawText(x(t), offsetY + height + 15, t, 10);


            canvas.ctx.textAlign = "right";
            for (let job in eventList.jobs) {
                console.log(job);
                canvas.drawText(offsetX - 10, y(job) + taskHeight / 2, job, 20);
            }

            for (let i = 0; i < eventList.cpus.length; i++) {
                canvas.drawText(offsetX - 10, y(i) + taskHeight / 2, `CPU${i}`, 20);
            }


            for (jobId in eventList.jobs) {
                let pos_y = y(jobId);
                let events = eventList.jobs[jobId];
                for (let i = 0; i < events.length; i++) {
                    let event = events[i];
                    if (event.event == "Release") {
                        canvas.setDrawMode("stroke")
                        canvas.setColor("Red");
                        canvas.setLineThickness(5);
                        canvas.drawLine(x(event.time), pos_y, x(event.time), pos_y + taskHeight);
                    }

                    if (event.event == "Process") {
                        // canvas.setDrawMode("fill");
                        canvas.setColor("green");
                        canvas.ctx.roundRect(x(event.startTime), pos_y, x(event.endTime) - x(event.startTime), taskHeight, 5);
                    }
                }
            }

            for (let i = 0; i < eventList.cpus.length; i++) {
                let pos_y = y(i);
                let events = eventList.cpus[i];
                for (let i = 0; i < events.length; i++) {
                    let event = events[i];
                    canvas.setDrawMode("fill");
                    if (event.event == "Idle") {
                        canvas.setDrawMode("fill");
                        canvas.setColor("grey");
                        canvas.drawRectangle(x(event.startTime), pos_y, x(event.endTime) - x(event.startTime), taskHeight);
                    }

                    if (event.event == "Overhead") {
                        canvas.setDrawMode("fill");
                        canvas.setColor("yellow");
                        canvas.drawRectangle(x(event.startTime), pos_y, x(event.endTime) - x(event.startTime), taskHeight);
                    }

                    if (event.event == "Process") {

                        canvas.setColor("blue");
                        canvas.drawRectangle(x(event.startTime), pos_y, x(event.endTime) - x(event.startTime), taskHeight);
                    }
                }
            }



        }

        function lcm(x, y) {
            if ((typeof x !== 'number') || (typeof y !== 'number'))
                return false;
            return (!x || !y) ? 0 : Math.abs((x * y) / gcd(x, y));
        }

        function gcd(x, y) {
            x = Math.abs(x);
            y = Math.abs(y);
            while (y) {
                var t = y;
                y = x % y;
                x = t;
            }
            return x;
        }


        canvas.setupFunction = newJob;

        $(function () {
            $("#sortable").sortable({
                placeholder: "ui-state-highlight",
                change: updateJobList,
                update: updateJobList
            });
            $("#sortable").disableSelection();
        });
    </script>



</body>

</html>